// Copyright 2019 Local Measure. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mongogen

import (
	"bytes"
	"fmt"

	"github.com/jinzhu/inflection"
)

type Generator struct {
	buf    bytes.Buffer
	indent string
}

func NewGenerator() *Generator {
	return &Generator{}
}

func (g *Generator) p(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, g.indent+format+"\n", args...)
}

func (g *Generator) in() {
	g.indent += "\t"
}

func (g *Generator) out() {
	if len(g.indent) > 0 {
		g.indent = g.indent[0 : len(g.indent)-1]
	}
}

func (g *Generator) Output() []byte {
	return g.buf.Bytes()
}

func (g *Generator) Gen(pkgName string, collection string, indexes []string) {
	public := toCamelCase(collection, true)
	singular := inflection.Singular(public)
	pkg := analyze(indexes, singular)
	filterTyp := singular + "Filter"
	g.p("// Code generated by MongoGen. DO NOT EDIT.")
	g.p("// Collection: %s", collection)
	g.p("")
	g.p("package %s", pkgName)
	g.p("")
	g.p("import (")
	g.in()
	for _, path := range pkg.imports {
		g.p("%q", path)
	}
	g.out()
	g.p(")")
	g.p("")

	g.p("func New(d *mongo.Database) *Svc {")
	g.in()
	g.p("return &Svc{d: d}")
	g.out()
	g.p("}")
	g.p("")

	g.p("type Svc struct {")
	g.in()
	g.p("d *mongo.Database")
	g.out()
	g.p("}")
	g.p("")

	g.p("type %s struct {", filterTyp)
	g.in()
	g.p("Filter bson.D")
	g.out()
	g.p("}")
	g.p("")

	g.p("func %sWithID(id primitive.ObjectID) %s {", singular, filterTyp)
	g.in()
	g.p("return %s{bson.D{{Key: %q, Value: %s}}}", filterTyp, "_id", "id")
	g.out()
	g.p("}")
	g.p("")

	g.p("func %sWithIDs(ids []primitive.ObjectID) %s {", singular, filterTyp)
	g.in()
	g.p("return %s{bson.D{{Key: %q, Value: bson.M{%q: ids}}}}", filterTyp, "_id", "$in")
	g.out()
	g.p("}")
	g.p("")

	for _, idx := range pkg.indexes {
		printIdxTyp(g, idx)
		g.p("")
		printIdxFn(g, idx)
		g.p("")
		printIdxFilter(g, idx, filterTyp)
		g.p("")
		for _, k := range idx.keys {
			ops, ok := typOps[k.typ]
			if ok {
				printOps(g, ops, k, idx.name)
			}
		}
	}

	g.p("func (s *Svc) Find(ctx context.Context, filter %s, opts ...*options.FindOptions) (*mongo.Cursor, error) {", filterTyp)
	g.in()
	g.p("return s.d.Collection(%q).Find(ctx, filter.Filter, opts...)", collection)
	g.out()
	g.p("}")
	g.p("")

	g.p("func (s *Svc) FindWithIDs(ctx context.Context, ids []primitive.ObjectID, opts ...*options.FindOptions) (*mongo.Cursor, error) {")
	g.in()
	g.p("return s.d.Collection(%q).Find(ctx, bson.M{%q: bson.M{%q: ids}}, opts...)", collection, "_id", "$in")
	g.out()
	g.p("}")
	g.p("")

	g.p("func (s *Svc) FindOne(ctx context.Context, filter %s, opts ...*options.FindOneOptions) *mongo.SingleResult {", filterTyp)
	g.in()
	g.p("return s.d.Collection(%q).FindOne(ctx, filter.Filter, opts...)", collection)
	g.out()
	g.p("}")
	g.p("")

	g.p("func (s *Svc) FindOneWithID(ctx context.Context, id primitive.ObjectID, opts ...*options.FindOneOptions) *mongo.SingleResult {")
	g.in()
	g.p("return s.d.Collection(%q).FindOne(ctx, bson.M{%q: id}, opts...)", collection, "_id")
	g.out()
	g.p("}")
	g.p("")

	g.p("func (s *Svc) InsertOne(ctx context.Context, document bson.M, opts ...*options.InsertOneOptions) (*mongo.InsertOneResult, error) {")
	g.in()
	g.p("return s.d.Collection(%q).InsertOne(ctx, document, opts...)", collection)
	g.out()
	g.p("}")
	g.p("")

	g.p("func (s *Svc) InsertMany(ctx context.Context, documents []interface{}, opts ...*options.InsertManyOptions) (*mongo.InsertManyResult, error) {")
	g.in()
	g.p("return s.d.Collection(%q).InsertMany(ctx, documents, opts...)", collection)
	g.out()
	g.p("}")
	g.p("")

	g.p("func (s *Svc) UpdateOne(ctx context.Context, id primitive.ObjectID, update bson.M, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) {")
	g.in()
	g.p("return s.d.Collection(%q).UpdateOne(ctx, bson.M{%q: id}, update, opts...)", collection, "_id")
	g.out()
	g.p("}")
	g.p("")

	g.p("func (s *Svc) UpdateMany(ctx context.Context, filter %s, update bson.M, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) {", filterTyp)
	g.in()
	g.p("return s.d.Collection(%q).UpdateMany(ctx, filter.Filter, update, opts...)", collection)
	g.out()
	g.p("}")
	g.p("")

	g.p("func (s *Svc) DeleteMany(ctx context.Context, filter %s, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {", filterTyp)
	g.in()
	g.p("return s.d.Collection(%q).DeleteMany(ctx, filter.Filter, opts...)", collection)
	g.out()
	g.p("}")
	g.p("")

	g.p("func (s *Svc) DeleteWithIDs(ctx context.Context, ids []primitive.ObjectID, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {")
	g.in()
	g.p("return s.d.Collection(%q).DeleteMany(ctx, bson.M{%q: bson.M{%q: ids}}, opts...)", collection, "_id", "$in")
	g.out()
	g.p("}")
	g.p("")

	g.p("func (s *Svc) DeleteOne(ctx context.Context, filter %s, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {", filterTyp)
	g.in()
	g.p("return s.d.Collection(%q).DeleteOne(ctx, filter.Filter, opts...)", collection)
	g.out()
	g.p("}")
	g.p("")

	g.p("func (s *Svc) DeleteOneWithID(ctx context.Context, id primitive.ObjectID, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {")
	g.in()
	g.p("return s.d.Collection(%q).DeleteOne(ctx, bson.M{%q: id}, opts...)", collection, "_id")
	g.out()
	g.p("}")
	g.p("")

	g.p("func (s *Svc) Count(ctx context.Context, filter %s, opts ...*options.CountOptions) (int64, error) {", filterTyp)
	g.in()
	g.p("return s.d.Collection(%q).CountDocuments(ctx, filter.Filter, opts...)", collection)
	g.out()
	g.p("}")
	g.p("")

	g.p("func (s *Svc) Aggregate(ctx context.Context, pipeline mongo.Pipeline, opts ...*options.AggregateOptions) (*mongo.Cursor, error) {")
	g.in()
	g.p("return s.d.Collection(%q).Aggregate(ctx, pipeline, opts...)", collection)
	g.out()
	g.p("}")
}

func printIdxTyp(g *Generator, idx index) {
	g.p("type %s struct {", idx.name)
	g.in()
	for _, k := range idx.keys {
		g.p("%-24sbson.M", k.goname)
	}
	g.out()
	g.p("}")
}

func printIdxFn(g *Generator, idx index) {
	fnName := toCamelCase(idx.name, true)
	g.p("func %s() *%s {", fnName, idx.name)
	g.in()
	g.p("return &%s{%s: bson.M{%q: 0}}", idx.name, idx.keys[0].goname, "$eq")
	g.out()
	g.p("}")
}

func printIdxFilter(g *Generator, idx index, filterTyp string) {
	g.p("func (use *%s) Build() %s {", idx.name, filterTyp)
	g.in()
	g.p("filter := bson.D{primitive.E{Key: %q, Value: use.%s}}", idx.keys[0].name, idx.keys[0].goname)
	for i := 1; i < len(idx.keys); i++ {
		g.p("if use.%s != nil {", idx.keys[i].goname)
		g.in()
		g.p("filter = append(filter, primitive.E{Key: %q, Value: use.%s})", idx.keys[i].name, idx.keys[i].goname)
		g.out()
		g.p("}")
	}
	g.p("return %s{filter}", filterTyp)
	g.out()
	g.p("}")
}

func printOps(g *Generator, ops []string, key indexKey, idxName string) {
	for _, op := range ops {
		switch op {
		case "eq":
			printEq(g, key, idxName)
		case "ne":
			printNe(g, key, idxName)
		case "in":
			printIn(g, key, idxName)
		case "nin":
			printNin(g, key, idxName)
		case "gt":
			printGt(g, key, idxName)
		case "gte":
			printGte(g, key, idxName)
		case "lt":
			printLt(g, key, idxName)
		case "lte":
			printLte(g, key, idxName)
		case "all":
			printAll(g, key, idxName)
		case "elemMatch":
			printElemMatch(g, key, idxName)
		case "size":
			printSize(g, key, idxName)
		}
		g.p("")
	}
}

func printEq(g *Generator, key indexKey, idxName string) {
	fnName := "With" + toCamelCase(key.goname, true)
	// multikey indexes will still have single value
	g.p("func (use *%s) %s(value %s) *%s {", idxName, fnName, key.literal, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$eq")
	g.p("return use")
	g.out()
	g.p("}")
}

func printNe(g *Generator, key indexKey, idxName string) {
	fnName := "With" + toCamelCase(key.goname, true) + "Ne"
	g.p("func (use *%s) %s(value %s) *%s {", idxName, fnName, key.literal, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$ne")
	g.p("return use")
	g.out()
	g.p("}")
}

func printIn(g *Generator, key indexKey, idxName string) {
	fnName := "With" + toCamelCase(key.goname, true) + "In"
	g.p("func (use *%s) %s(values %s) *%s {", idxName, fnName, "[]"+key.literal, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: values}", key.goname, "$in")
	g.p("return use")
	g.out()
	g.p("}")
}

func printNin(g *Generator, key indexKey, idxName string) {
	fnName := "With" + toCamelCase(key.goname, true) + "Nin"
	g.p("func (use *%s) %s(values %s) *%s {", idxName, fnName, "[]"+key.literal, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: values}", key.goname, "$nin")
	g.p("return use")
	g.out()
	g.p("}")
}

func printGt(g *Generator, key indexKey, idxName string) {
	fnName := "With" + toCamelCase(key.goname, true) + "Gt"
	g.p("func (use *%s) %s(value %s) *%s {", idxName, fnName, key.literal, idxName)
	g.in()
	g.p("if use.%s != nil {", key.goname)
	g.in()
	g.p("use.%s[%q] = value", key.goname, "$gt")
	g.out()
	g.p("} else {")
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$gt")
	g.out()
	g.p("}")
	g.p("return use")
	g.out()
	g.p("}")
}

func printGte(g *Generator, key indexKey, idxName string) {
	fnName := "With" + toCamelCase(key.goname, true) + "Gte"
	g.p("func (use *%s) %s(value %s) *%s {", idxName, fnName, key.literal, idxName)
	g.in()
	g.p("if use.%s != nil {", key.goname)
	g.in()
	g.p("use.%s[%q] = value", key.goname, "$gte")
	g.out()
	g.p("} else {")
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$gte")
	g.out()
	g.p("}")
	g.p("return use")
	g.out()
	g.p("}")
}

func printLt(g *Generator, key indexKey, idxName string) {
	fnName := "With" + toCamelCase(key.goname, true) + "Lt"
	g.p("func (use *%s) %s(value %s) *%s {", idxName, fnName, key.literal, idxName)
	g.in()
	g.p("if use.%s != nil {", key.goname)
	g.in()
	g.p("use.%s[%q] = value", key.goname, "$lt")
	g.out()
	g.p("} else {")
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$lt")
	g.out()
	g.p("}")
	g.p("return use")
	g.out()
	g.p("}")
}

func printLte(g *Generator, key indexKey, idxName string) {
	fnName := "With" + toCamelCase(key.goname, true) + "Lte"
	g.p("func (use *%s) %s(value %s) *%s {", idxName, fnName, key.literal, idxName)
	g.in()
	g.p("if use.%s != nil {", key.goname)
	g.in()
	g.p("use.%s[%q] = value", key.goname, "$lte")
	g.out()
	g.p("} else {")
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$lte")
	g.out()
	g.p("}")
	g.p("return use")
	g.out()
	g.p("}")
}

func printAll(g *Generator, key indexKey, idxName string) {
	fnName := "With" + toCamelCase(key.goname, true) + "All"
	g.p("func (use *%s) %s(values %s) *%s {", idxName, fnName, "[]"+key.literal, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: values}", key.goname, "$all")
	g.p("return use")
	g.out()
	g.p("}")
}

func printElemMatch(g *Generator, key indexKey, idxName string) {
	fnName := "With" + toCamelCase(key.goname, true) + "ElemMatch"
	g.p("func (use *%s) %s(value bson.M) *%s {", idxName, fnName, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$elemMatch")
	g.p("return use")
	g.out()
	g.p("}")
}

func printSize(g *Generator, key indexKey, idxName string) {
	fnName := "With" + toCamelCase(key.goname, true) + "Size"
	g.p("func (use *%s) %s(value int) *%s {", idxName, fnName, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$size")
	g.p("return use")
	g.out()
	g.p("}")
}
