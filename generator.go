// Copyright 2019 Local Measure. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package mongogen

import (
	"bytes"
	"fmt"

	"github.com/jinzhu/inflection"
)

type Generator struct {
	buf    bytes.Buffer
	indent string
}

func NewGenerator() *Generator {
	return &Generator{}
}

func (g *Generator) p(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, g.indent+format+"\n", args...)
}

func (g *Generator) in() {
	g.indent += "\t"
}

func (g *Generator) out() {
	if len(g.indent) > 0 {
		g.indent = g.indent[0 : len(g.indent)-1]
	}
}

func (g *Generator) Output() []byte {
	return g.buf.Bytes()
}

func (g *Generator) Gen(pkgName string, collection string, indexes []string) {
	public := toCamelCase(collection, true)
	pkg := analyze(indexes, inflection.Singular(public))
	g.p("// Code generated by MongoGen. DO NOT EDIT.")
	g.p("// Collection: %s", collection)
	g.p("")
	g.p("package %s", pkgName)
	g.p("")
	g.p("import (")
	g.in()
	for _, path := range pkg.imports {
		g.p("%q", path)
	}
	g.out()
	g.p(")")
	g.p("")
	for _, idx := range pkg.indexes {
		printIdxTyp(g, idx)
		g.p("")
		printIdxFn(g, idx)
		g.p("")
		printIdxFilter(g, idx)
		g.p("")
		for _, k := range idx.keys {
			ops, ok := typOps[k.typ]
			if ok {
				printOps(g, ops, k, idx.name)
			}
		}
	}
}

func printIdxTyp(g *Generator, idx index) {
	g.p("type %s struct {", idx.name)
	g.in()
	g.p("%s bool", "isSet")
	for _, k := range idx.keys {
		g.p("%s bson.M", k.goname)
	}
	g.out()
	g.p("}")
}

func printIdxFn(g *Generator, idx index) {
	fnName := toCamelCase(idx.name, true)
	g.p("func %s() *%s {", fnName, idx.name)
	g.in()
	g.p("return &%s{}", idx.name)
	g.out()
	g.p("}")
}

func printIdxFilter(g *Generator, idx index) {
	g.p("func (use *%s) Build() bson.D {", idx.name)
	if len(idx.keys) == 1 {
		g.in()
		g.p("return bson.D{primitive.E{Key: %q, Value: use.%s}}", idx.keys[0].name, idx.keys[0].goname)
		g.out()
		g.p("}")
		return
	}
	g.in()
	g.p("filter := bson.D{primitive.E{Key: %q, Value: use.%s}}", idx.keys[0].name, idx.keys[0].goname)
	for i := 1; i < len(idx.keys); i++ {
		g.p("if use.%s != nil {", idx.keys[i].goname)
		g.in()
		g.p("filter = append(filter, primitive.E{Key: %q, Value: use.%s})", idx.keys[i].name, idx.keys[i].goname)
		g.out()
		g.p("}")
	}
	g.p("return filter")
	g.out()
	g.p("}")
}

func printOps(g *Generator, ops []string, key indexKey, idxName string) {
	for _, op := range ops {
		switch op {
		case "eq":
			printEq(g, key, idxName)
		case "ne":
			printNe(g, key, idxName)
		case "in":
			printIn(g, key, idxName)
		case "nin":
			printNin(g, key, idxName)
		case "gt":
			printGt(g, key, idxName)
		case "gte":
			printGte(g, key, idxName)
		case "lt":
			printLt(g, key, idxName)
		case "lte":
			printLte(g, key, idxName)
		case "all":
			printAll(g, key, idxName)
		case "elemMatch":
			printElemMatch(g, key, idxName)
		case "size":
			printSize(g, key, idxName)
		}
		g.p("")
	}
}

func printEq(g *Generator, key indexKey, idxName string) {
	fnName := toCamelCase(key.goname, true)
	if fnName == "Id" {
		fnName = "IdEq"
	}
	// multikey indexes will still have single value
	g.p("func (use *%s) %s(value %s) *%s {", idxName, fnName, key.literal, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$eq")
	g.p("return use")
	g.out()
	g.p("}")
}

func printNe(g *Generator, key indexKey, idxName string) {
	fnName := toCamelCase(key.goname, true) + "Ne"
	g.p("func (use *%s) %s(value %s) *%s {", idxName, fnName, key.literal, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$ne")
	g.p("return use")
	g.out()
	g.p("}")
}

func printIn(g *Generator, key indexKey, idxName string) {
	fnName := toCamelCase(key.goname, true) + "In"
	g.p("func (use *%s) %s(values %s) *%s {", idxName, fnName, "[]"+key.literal, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: values}", key.goname, "$in")
	g.p("return use")
	g.out()
	g.p("}")
}

func printNin(g *Generator, key indexKey, idxName string) {
	fnName := toCamelCase(key.goname, true) + "Nin"
	g.p("func (use *%s) %s(values %s) *%s {", idxName, fnName, "[]"+key.literal, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: values}", key.goname, "$nin")
	g.p("return use")
	g.out()
	g.p("}")
}

func printGt(g *Generator, key indexKey, idxName string) {
	fnName := toCamelCase(key.goname, true) + "Gt"
	g.p("func (use *%s) %s(value %s) *%s {", idxName, fnName, key.literal, idxName)
	g.in()
	g.p("if use.isSet {")
	g.in()
	g.p("use.%s[%q] = value", key.goname, "$gt")
	g.out()
	g.p("} else {")
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$gt")
	g.p("use.isSet = true")
	g.out()
	g.p("}")
	g.p("return use")
	g.out()
	g.p("}")
}

func printGte(g *Generator, key indexKey, idxName string) {
	fnName := toCamelCase(key.goname, true) + "Gte"
	g.p("func (use *%s) %s(value %s) *%s {", idxName, fnName, key.literal, idxName)
	g.in()
	g.p("if use.isSet {")
	g.in()
	g.p("use.%s[%q] = value", key.goname, "$gte")
	g.out()
	g.p("} else {")
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$gte")
	g.p("use.isSet = true")
	g.out()
	g.p("}")
	g.p("return use")
	g.out()
	g.p("}")
}

func printLt(g *Generator, key indexKey, idxName string) {
	fnName := toCamelCase(key.goname, true) + "Lt"
	g.p("func (use *%s) %s(value %s) *%s {", idxName, fnName, key.literal, idxName)
	g.in()
	g.p("if use.isSet {")
	g.in()
	g.p("use.%s[%q] = value", key.goname, "$lt")
	g.out()
	g.p("} else {")
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$lt")
	g.p("use.isSet = true")
	g.out()
	g.p("}")
	g.p("return use")
	g.out()
	g.p("}")
}

func printLte(g *Generator, key indexKey, idxName string) {
	fnName := toCamelCase(key.goname, true) + "Lte"
	g.p("func (use *%s) %s(value %s) *%s {", idxName, fnName, key.literal, idxName)
	g.in()
	g.p("if use.isSet {")
	g.in()
	g.p("use.%s[%q] = value", key.goname, "$lte")
	g.out()
	g.p("} else {")
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$lte")
	g.p("use.isSet = true")
	g.out()
	g.p("}")
	g.p("return use")
	g.out()
	g.p("}")
}

func printAll(g *Generator, key indexKey, idxName string) {
	fnName := toCamelCase(key.goname, true) + "All"
	g.p("func (use *%s) %s(values %s) *%s {", idxName, fnName, "[]"+key.literal, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: values}", key.goname, "$all")
	g.p("return use")
	g.out()
	g.p("}")
}

func printElemMatch(g *Generator, key indexKey, idxName string) {
	fnName := toCamelCase(key.goname, true) + "ElemMatch"
	g.p("func (use *%s) %s(value bson.M) *%s {", idxName, fnName, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$elemMatch")
	g.p("return use")
	g.out()
	g.p("}")
}

func printSize(g *Generator, key indexKey, idxName string) {
	fnName := toCamelCase(key.goname, true) + "Size"
	g.p("func (use *%s) %s(value int) *%s {", idxName, fnName, idxName)
	g.in()
	g.p("use.%s = bson.M{%q: value}", key.goname, "$size")
	g.p("return use")
	g.out()
	g.p("}")
}
