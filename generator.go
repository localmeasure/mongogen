package mongogen

import (
	"bytes"
	"fmt"
	"strings"
)

var goKeywords = map[string]struct{}{
	"break":       struct{}{},
	"default":     struct{}{},
	"func":        struct{}{},
	"interface":   struct{}{},
	"select":      struct{}{},
	"case":        struct{}{},
	"defer":       struct{}{},
	"go":          struct{}{},
	"map":         struct{}{},
	"struct":      struct{}{},
	"chan":        struct{}{},
	"else":        struct{}{},
	"goto":        struct{}{},
	"package":     struct{}{},
	"switch":      struct{}{},
	"const":       struct{}{},
	"fallthrough": struct{}{},
	"if":          struct{}{},
	"range":       struct{}{},
	"type":        struct{}{},
	"continue":    struct{}{},
	"for":         struct{}{},
	"import":      struct{}{},
	"return":      struct{}{},
	"var":         struct{}{},
}

type Generator struct {
	PackageName string
	buf         bytes.Buffer
	indent      string
}

func NewGenerator(packageName string) *Generator {
	return &Generator{PackageName: packageName}
}

func (g *Generator) p(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, g.indent+format+"\n", args...)
}

func (g *Generator) in() {
	g.indent += "\t"
}

func (g *Generator) out() {
	if len(g.indent) > 0 {
		g.indent = g.indent[0 : len(g.indent)-1]
	}
}

func (g *Generator) Generate(pkg *Pkg) {
	g.p("// Code generated by MongoGen. DO NOT EDIT.")
	g.p("// Database: %v", pkg.Database)
	g.p("// Collections to types: %v", pkg.Database)
	for _, t := range pkg.Types {
		g.p("// \t" + t.Collection + strings.Repeat(" ", 30-len(t.Collection)) + t.Plural)
	}
	g.p("")
	g.p("package %v", g.PackageName)
	g.p("")
	g.p("import (")
	g.in()
	for _, path := range pkg.Imports {
		g.p("%q", path)
	}
	g.out()
	g.p(")")
	g.p("")

	for _, t := range pkg.Types {
		g.p("type %v struct {", t.Plural)
		g.in()
		g.p("db *mongo.Database")
		g.out()
		g.p("}")
		g.p("")

		for _, m := range t.Methods {
			g.p("func " + m.Name + "(" + printMethodArgs(m.Args) + ") bson.D {")
			g.in()
			g.p(printMethodReturn(m.Args))
			g.out()
			g.p("}")
			g.p("")
		}

		g.p("func (s *" + t.Plural + ") Find(ctx context.Context, filter bson.D, opts ...*options.FindOptions) (*mongo.Cursor, error) {")
		g.in()
		g.p("return s.db.Collection(%q).Find(ctx, filter, opts...)", t.Collection)
		g.out()
		g.p("}")
		g.p("")

		g.p("func (s *" + t.Plural + ") FindOne(ctx context.Context, filter bson.D, opts ...*options.FindOneOptions) *mongo.SingleResult {")
		g.in()
		g.p("return s.db.Collection(%q).FindOne(ctx, filter, opts...)", t.Collection)
		g.out()
		g.p("}")
		g.p("")
	}
}

func printMethodArgs(args []Argument) string {
	out := ""
	for _, arg := range args {
		out += escapeGoKeyword(arg.ArgName) + " " + arg.ArgType + ", "
	}
	return out[:len(out)-2]
}

func printMethodReturn(args []Argument) string {
	out := ""
	for _, arg := range args {
		out += "{Key: \"" + arg.QueryName + "\", Value: " + escapeGoKeyword(arg.ArgName) + "}, "
	}
	return "return bson.D{" + out[:len(out)-2] + "}"
}

func (g *Generator) Output() []byte {
	return g.buf.Bytes()
}

func escapeGoKeyword(key string) string {
	if _, matched := goKeywords[key]; matched {
		return key + "Arg"
	}
	return key
}
