// +build ignore
// Code generated by MongoGen. DO NOT EDIT.
// Collection: users

package users

import (
	"time"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"context"
)

var db *mongo.Database

func SetDB(d *mongo.Database) {
	db = d
}

type UserFilter struct {
	Filter bson.D
}

func UserWithID(id primitive.ObjectID) UserFilter {
	return UserFilter{bson.D{{Key: "_id", Value: id}}}
}

func UserWithIDs(ids []primitive.ObjectID) UserFilter {
	return UserFilter{bson.D{{Key: "_id", Value: bson.M{"$in": ids}}}}
}

type useGroupId struct {
	groupId                 bson.M
	name                    bson.M
}

func UseGroupId() *useGroupId {
	return &useGroupId{groupId: bson.M{"$eq": 0}}
}

func (use *useGroupId) Build() UserFilter {
	filter := bson.D{primitive.E{Key: "group_id", Value: use.groupId}}
	if use.name != nil {
		filter = append(filter, primitive.E{Key: "name", Value: use.name})
	}
	return UserFilter{filter}
}

func (use *useGroupId) WithGroupId(value primitive.ObjectID) *useGroupId {
	use.groupId = bson.M{"$eq": value}
	return use
}

func (use *useGroupId) WithGroupIdNe(value primitive.ObjectID) *useGroupId {
	use.groupId = bson.M{"$ne": value}
	return use
}

func (use *useGroupId) WithGroupIdIn(values []primitive.ObjectID) *useGroupId {
	use.groupId = bson.M{"$in": values}
	return use
}

func (use *useGroupId) WithGroupIdNin(values []primitive.ObjectID) *useGroupId {
	use.groupId = bson.M{"$nin": values}
	return use
}

func (use *useGroupId) WithGroupIdGt(value primitive.ObjectID) *useGroupId {
	if use.groupId != nil {
		use.groupId["$gt"] = value
	} else {
		use.groupId = bson.M{"$gt": value}
	}
	return use
}

func (use *useGroupId) WithGroupIdGte(value primitive.ObjectID) *useGroupId {
	if use.groupId != nil {
		use.groupId["$gte"] = value
	} else {
		use.groupId = bson.M{"$gte": value}
	}
	return use
}

func (use *useGroupId) WithGroupIdLt(value primitive.ObjectID) *useGroupId {
	if use.groupId != nil {
		use.groupId["$lt"] = value
	} else {
		use.groupId = bson.M{"$lt": value}
	}
	return use
}

func (use *useGroupId) WithGroupIdLte(value primitive.ObjectID) *useGroupId {
	if use.groupId != nil {
		use.groupId["$lte"] = value
	} else {
		use.groupId = bson.M{"$lte": value}
	}
	return use
}

func (use *useGroupId) WithName(value string) *useGroupId {
	use.name = bson.M{"$eq": value}
	return use
}

func (use *useGroupId) WithNameNe(value string) *useGroupId {
	use.name = bson.M{"$ne": value}
	return use
}

func (use *useGroupId) WithNameIn(values []string) *useGroupId {
	use.name = bson.M{"$in": values}
	return use
}

func (use *useGroupId) WithNameNin(values []string) *useGroupId {
	use.name = bson.M{"$nin": values}
	return use
}

type useTeamId struct {
	teamId                  bson.M
	lastSeen                bson.M
}

func UseTeamId() *useTeamId {
	return &useTeamId{teamId: bson.M{"$eq": 0}}
}

func (use *useTeamId) Build() UserFilter {
	filter := bson.D{primitive.E{Key: "team_id", Value: use.teamId}}
	if use.lastSeen != nil {
		filter = append(filter, primitive.E{Key: "last_seen", Value: use.lastSeen})
	}
	return UserFilter{filter}
}

func (use *useTeamId) WithTeamId(value primitive.ObjectID) *useTeamId {
	use.teamId = bson.M{"$eq": value}
	return use
}

func (use *useTeamId) WithTeamIdNe(value primitive.ObjectID) *useTeamId {
	use.teamId = bson.M{"$ne": value}
	return use
}

func (use *useTeamId) WithTeamIdIn(values []primitive.ObjectID) *useTeamId {
	use.teamId = bson.M{"$in": values}
	return use
}

func (use *useTeamId) WithTeamIdNin(values []primitive.ObjectID) *useTeamId {
	use.teamId = bson.M{"$nin": values}
	return use
}

func (use *useTeamId) WithTeamIdGt(value primitive.ObjectID) *useTeamId {
	if use.teamId != nil {
		use.teamId["$gt"] = value
	} else {
		use.teamId = bson.M{"$gt": value}
	}
	return use
}

func (use *useTeamId) WithTeamIdGte(value primitive.ObjectID) *useTeamId {
	if use.teamId != nil {
		use.teamId["$gte"] = value
	} else {
		use.teamId = bson.M{"$gte": value}
	}
	return use
}

func (use *useTeamId) WithTeamIdLt(value primitive.ObjectID) *useTeamId {
	if use.teamId != nil {
		use.teamId["$lt"] = value
	} else {
		use.teamId = bson.M{"$lt": value}
	}
	return use
}

func (use *useTeamId) WithTeamIdLte(value primitive.ObjectID) *useTeamId {
	if use.teamId != nil {
		use.teamId["$lte"] = value
	} else {
		use.teamId = bson.M{"$lte": value}
	}
	return use
}

func (use *useTeamId) WithLastSeenGt(value time.Time) *useTeamId {
	if use.lastSeen != nil {
		use.lastSeen["$gt"] = value
	} else {
		use.lastSeen = bson.M{"$gt": value}
	}
	return use
}

func (use *useTeamId) WithLastSeenGte(value time.Time) *useTeamId {
	if use.lastSeen != nil {
		use.lastSeen["$gte"] = value
	} else {
		use.lastSeen = bson.M{"$gte": value}
	}
	return use
}

func (use *useTeamId) WithLastSeenLt(value time.Time) *useTeamId {
	if use.lastSeen != nil {
		use.lastSeen["$lt"] = value
	} else {
		use.lastSeen = bson.M{"$lt": value}
	}
	return use
}

func (use *useTeamId) WithLastSeenLte(value time.Time) *useTeamId {
	if use.lastSeen != nil {
		use.lastSeen["$lte"] = value
	} else {
		use.lastSeen = bson.M{"$lte": value}
	}
	return use
}

func Find(ctx context.Context, filter UserFilter, opts ...*options.FindOptions) (*mongo.Cursor, error) {
	return db.Collection("users").Find(ctx, filter.Filter, opts...)
}

func FindWithIDs(ctx context.Context, ids []primitive.ObjectID, opts ...*options.FindOptions) (*mongo.Cursor, error) {
	return db.Collection("users").Find(ctx, bson.M{"_id": bson.M{"$in": ids}}, opts...)
}

func FindOne(ctx context.Context, filter UserFilter, opts ...*options.FindOneOptions) *mongo.SingleResult {
	return db.Collection("users").FindOne(ctx, filter.Filter, opts...)
}

func FindOneWithID(ctx context.Context, id primitive.ObjectID, opts ...*options.FindOneOptions) *mongo.SingleResult {
	return db.Collection("users").FindOne(ctx, bson.M{"_id": id}, opts...)
}

func InsertOne(ctx context.Context, document bson.M, opts ...*options.InsertOneOptions) (*mongo.InsertOneResult, error) {
	return db.Collection("users").InsertOne(ctx, document, opts...)
}

func InsertMany(ctx context.Context, documents []interface{}, opts ...*options.InsertManyOptions) (*mongo.InsertManyResult, error) {
	return db.Collection("users").InsertMany(ctx, documents, opts...)
}

func UpdateOne(ctx context.Context, id primitive.ObjectID, update bson.M, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	return db.Collection("users").UpdateOne(ctx, bson.M{"_id": id}, update, opts...)
}

func UpdateMany(ctx context.Context, filter UserFilter, update bson.M, opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	return db.Collection("users").UpdateMany(ctx, filter.Filter, update, opts...)
}

func DeleteMany(ctx context.Context, filter UserFilter, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	return db.Collection("users").DeleteMany(ctx, filter.Filter, opts...)
}

func DeleteWithIDs(ctx context.Context, ids []primitive.ObjectID, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	return db.Collection("users").DeleteMany(ctx, bson.M{"_id": bson.M{"$in": ids}}, opts...)
}

func DeleteOne(ctx context.Context, filter UserFilter, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	return db.Collection("users").DeleteOne(ctx, filter.Filter, opts...)
}

func DeleteOneWithID(ctx context.Context, id primitive.ObjectID, opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	return db.Collection("users").DeleteOne(ctx, bson.M{"_id": id}, opts...)
}

func Count(ctx context.Context, filter UserFilter, opts ...*options.CountOptions) (int64, error) {
	return db.Collection("users").CountDocuments(ctx, filter.Filter, opts...)
}

func Aggregate(ctx context.Context, pipeline mongo.Pipeline, opts ...*options.AggregateOptions) (*mongo.Cursor, error) {
	return db.Collection("users").Aggregate(ctx, pipeline, opts...)
}
